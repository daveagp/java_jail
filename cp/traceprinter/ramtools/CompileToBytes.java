package traceprinter.ramtools;

import javax.tools.*;
import java.io.*;
import java.util.*;

public class CompileToBytes {

    public Writer compilerOutput = null; 
    // a Writer for additional output from the compiler; use System.err if null

    public DiagnosticListener<? super JavaFileObject> diagnosticListener = null;
    // a diagnostic (warning, etc) listener; if null use the compiler's default method for reporting diagnostics

    public Iterable<String> options = null;
    // args[] for javac, null means no options
        
    public Iterable<String> classesForAnnotation = null;
    // names of classes to be processed by annotation processing, null means no class names

    public Map<String, byte[]> bytecodes;
    // output variable: the class names and bytecodes generated by compiling
    
    private boolean used = false;

    public CompileToBytes() {}

    /***
        Compiles a single source file to bytecode.
        Returns null if compilation failed (same as JavaCompiler.getTask.call => false).
        Otherwise, returns bytecode for files defined as a result of compiling.
    ***/

    public Map<String, byte[]> compileFile(String className, String sourceCode) {
        if (used) throw new RuntimeException("You already used this CompileToBytes.");
        used = true;
        
        ArrayList<RAMJavaFile> sourceFiles = new ArrayList<>();
        sourceFiles.add(new RAMJavaFile(className, sourceCode));
        
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();

        RAMClassFileManager fileManager = new
            RAMClassFileManager(compiler
                                .getStandardFileManager(null, null, null));

        boolean result = compiler.getTask(compilerOutput, fileManager, diagnosticListener, 
                                          options, classesForAnnotation, sourceFiles).call();

        if (!result) return null;

        bytecodes = new TreeMap<>();
        for (Map.Entry<String, RAMClassFile> me : fileManager.contents.entrySet()) {
            bytecodes.put(me.getKey(), me.getValue().getBytes());
        }

        return bytecodes;
    }
}